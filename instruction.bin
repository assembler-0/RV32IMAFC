# Basic arithmetic and logic
0x02a00093 # addi x1, x0, 42 -> x1 = 42
0x00108133 # add x2, x1, x1 -> x2 = 84
0x401101b3 # sub x3, x2, x1 -> x3 = 42
0x00209213 # slli x4, x1, 2 -> x4 = 168
0x022082b3 # mul x5, x1, x2 -> x5 = 3528
0x0212c333 # div x6, x5, x1 -> x6 = 84
0x00f0f393 # andi x7, x1, 15 -> x7 = 10
0x0010e413 # ori x8, x1, 1 -> x8 = 43
0x0070c493 # xori x9, x1, 7 -> x9 = 45
0x0320a513 # slti x10, x1, 50 -> x10 = 1
0x01e0b593 # sltiu x11, x1, 30 -> x11 = 0
0x12345637 # lui x12, 0x12345 -> x12 = 0x12345000
0x01000697 # auipc x13, 0x10000 -> x13 = pc + 0x10000

# Store and Branch tests
0x00100793 # addi x15, x0, 1
0x00000013 # nop
0x00f7a023 # sw x15, 0(x15)
0x00000013 # nop
0x00100793 # addi x15, x0, 1
0x00000013 # nop
0x00f78863 # beq x15, x15, 16 # Branch taken
0x00000013 # nop
0x00000013 # nop
0x00000013 # nop
0x00100793 # addi x15, x0, 1
0x00f09863 # bne x15, x0, 16 # Branch taken
0x00000013 # nop
0x00000013 # nop
0x00000013 # nop

# JAL and JALR tests
0x018000ef # jal x1, 24
0x00000013 # nop
0x00000013 # nop
0x00000013 # nop
0x00000013 # nop
0x00000013 # nop
0x000081e7 # jalr x3, x1, 0

# System instructions
# Set MTVEC to 0x100000
0x01000037 # lui x6, 0x100
0x305f9073 # csrrw x0, mtvec, x6

# Set STVEC to 0x200000
0x02000037 # lui x6, 0x200
0x105f9073 # csrrw x0, stvec, x6

# Set MSTATUS to allow S-mode (MPP = 01, MPIE = 1)
0x0080037 # lui x6, 0x800 # MPP = 01 (S-mode), MPIE = 1
0x300f9073 # csrrw x0, mstatus, x6

# Set SSTATUS to allow U-mode (SPP = 0, SPIE = 1)
0x0000037 # lui x6, 0x0 # SPP = 0 (U-mode), SPIE = 1
0x100f9073 # csrrw x0, sstatus, x6

# ECALL from M-mode (should jump to MTVEC)
0x00000097 # auipc x1, 0
0x00808093 # addi x1, x1, 8 # PC + 8 (address of mret)
0x34109073 # csrrw x0, mepc, x1 # Save PC of next instruction to MEPC
0x00000073 # ecall
0x00000013 # nop (should not be executed)

# MRET (should return to MEPC and change privilege)
0x30200073 # mret
0x00000013 # nop (should be executed after MRET)

# ECALL from S-mode (should jump to STVEC)
0x00000097 # auipc x1, 0
0x00808093 # addi x1, x1, 8 # PC + 8 (address of sret)
0x14109073 # csrrw x0, sepc, x1 # Save PC of next instruction to SEPC
0x00000073 # ecall
0x00000013 # nop (should not be executed)

# SRET (should return to SEPC and change privilege)
0x10200073 # sret
0x00000013 # nop (should be executed after SRET)

# ECALL from U-mode (should jump to MTVEC)
0x00000097 # auipc x1, 0
0x00808093 # addi x1, x1, 8 # PC + 8 (address of uret)
0x34109073 # csrrw x0, mepc, x1 # Save PC of next instruction to MEPC
0x00000073 # ecall
0x00000013 # nop (should not be executed)

# URET (treated as NOP for now)
0x00200073 # uret

# Atomic instructions
0x001007b7 # lui x15, 0x10000 # Set x15 to 0x1000
0x00078793 # addi x15, x15, 0 # Set x15 to 0x1000
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Set x5 to initial value (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Set x5 to initial value (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0207a22f # lr.w x5, (x15) # Load Reserved Word (x5 should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x0007a02f # sc.w x0, x0, (x15) # Store Conditional (should fail, x0=0)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0207a22f # lr.w x5, (x15) # Load Reserved Word (x5 should be 0x12345678)
0x00000013 # nop
0x87654237 # lui x5, 0x87654 # Set x5 to new value for SC (upper 20 bits)
0x32128293 # addi x5, x5, 0x321 # Set x5 to new value for SC (lower 12 bits)
0x00000013 # nop
0x0007a02f # sc.w x0, x5, (x15) # Store Conditional (should succeed, x0=0)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x87654321)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amoswap.w x0, x5, (x15) # Atomic Swap (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amoadd.w x0, x5, (x15) # Atomic Add (x0 should be 0x12345678, memory should be 0x2468acf0)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x2468acf0)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amoxor.w x0, x5, (x15) # Atomic XOR (x0 should be 0x12345678, memory should be 0x0)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x0)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amoand.w x0, x5, (x15) # Atomic AND (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amoor.w x0, x5, (x15) # Atomic OR (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amomin.w x0, x5, (x15) # Atomic MIN (signed) (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amomax.w x0, x5, (x15) # Atomic MAX (signed) (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amominu.w x0, x5, (x15) # Atomic MIN (unsigned) (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

0x001007b7 # lui x15, 0x10000 # Reset x15 for next test
0x00078793 # addi x15, x15, 0 # Reset x15 for next test
0x00000013 # nop
0x12345237 # lui x5, 0x12345 # Reset x5 for next test (upper 20 bits)
0x67828293 # addi x5, x5, 0x678 # Reset x5 for next test (lower 12 bits)
0x00000013 # nop
0x0007a023 # sw x5, 0(x15) # Store initial value to memory
0x00000013 # nop

0x0007a02f # amomaxu.w x0, x5, (x15) # Atomic MAX (unsigned) (x0 should be 0x12345678, memory should be 0x12345678)
0x00000013 # nop
0x0007a783 # lw x29, 0(x15) # Read memory to verify (x29 should be 0x12345678)
0x00000013 # nop

# CSR tests
0x30001073 # csrrw x1, mstatus, x0
0x300020f3 # csrrs x1, mstatus, x0
